#+TITLE: Todo

поменять типы на какие-то свои уникальные, указанные в начале, чтобы потом не ебаться с переименовыванием

на 1 элемент и его положение в массивах ссылаются:
    1. 2 элемента из связного списка для переноса строк
    2. ребёнок левый
1 элемент ссылается на:
    1. 2 элемента из связного списка для переноса строк
    2. строку со значением
    3. *ребёнка* - или скорее там есть указатели на ребёнка
на 1 блок-элемент ссылаются: ляя запись будет долгая
    1. все, кто ссылается на элементы этого блока
    2. родитель блока
1 блок-элемент ссылается на:
    1. всех, на кого ссылаются элементы этого блока
    2. элемент-родителя



[ abcvcv 123 asdfasdf 345        ]
[ [ [][][] | [][][][] ] [ [][][] | [][][][] ] [ [][][] ][ [][][] ]                    ]

int + unsigned char-указатель на 1 элемент, нужно в самом дереве самый первый элемент этого списка
как-то выделить, например что-то отрицательное в этих интах и чарах или хз что, ведь как-то нужно будет
менять, а если кароче хранить реальный указатель, а при перемещении просто менять указатель на новый?
# но тогда будет указатель на указатель, который на указатель и тд... скорее всего тогда void*,
# но если указатель будет ссылаться на указатель, он же на элемент не будет ссылаться, лучше так не делать
# таак, а если реально указателя 2 хранить вперёд и назад? тогда при перемещении элемента нужно будет менять
# 2 указателя, но это норм наверное, только нужно иметь где-то элемент 0-ой, на который будет ссылаться 1-ый
# в списке -> нужен элемент; хотя тогда при переносе дерева в другое место будет пздц, так как ссылки пойдут плохо,
# *но!*, но можно при записи использовать относительные указатели, хотя это пиздец, проще иметь 0-ой элемент какой-то,
но он тогда хз, будет занимать место и тд, проще как-то обозначить, что элемент указывает на -1-ый, можно кароче
сделать костыль, а можно всё-таки через отрицательные числа, но в конечном итоге юзать указатели не надо
наверное проще всего использовать char, вместо unsigned char - и тогда будет возможность обозначить
несуществующие какие-то адреса, но это нужно пока что только для переноса строк

дерево-массив:
    [][][]...[] | int - номер первого элемента, который указывает на первую строку+число слева
    int-указатель на первый свободный элемент == список свободных элементов -> нужно пройтись по массиву
    и проставить этот список
    int-номер крайнего правого занятого элемента - чтобы потом лениво записать всё до него в файл
элемент дерева-массива:
    # то есть нужен ещё какой-то элемент, который указывает, есть ли здесь или нет элемент сам,
    # но наверное можно просто сравнить какой-то инт отсюда с 0, хотя если выделять лениво, то зануления не будет
    # и нужно всё таки занулить тогда что-то, например - *сколько используется*
    но если элемент есть в списке свободных, то зачем тогда там нужно показывать, что элемент пустой?
    хз пока
    и нужно какой-то инт-указатель юзать как инт-указатель на следующий
    элемент - скорее всего *указатель на родителя*
    можно биты в чаре использовать, чтобы показать, кто является первым элементом
    *у него кстати может быть меньше n-1*

    [   2n - 1 элементов в каждом узле, могут быть пустые [][]...[] /
    /   2n int-указателей на другие узлы дерева-массива, сюда идём только после верхнего массива
    /   int - номер (в дереве-массиве) родителя +
        (можно просто искать по ключу, но так наверное быстрее) ~unsigned char~ - номер родителя в элементе дерева-массива
    /   ~unsigned char~ - сколько используется - заполняем слева направо наверное - проще всего
        к тому же сколько используется - однозначно >= n-1, значит здесь можно хранить прибавку именно,
        а оставшиеся биты для информации, например если там отрицательное число -> пустой элемент

    /    ] |
элемент узла:
    [   int индекс начала строки + значения |
        int - номер следующего элемента в дереве-массиве, который указывает на правую строку +
        ~unsigned char~ - номер в элементе дерева-массива
        и на меня ссылающиеся: int - номер предыдущего элемента в дереве-массиве, который указывает на правую строку +
        ~unsigned char~ - номер в элементе дерева-массива ]
        # element* forward;
        # element* next;
(14 * (2n-1) + 10 * 2n + 6) * k = (48n - 8) * k байт - всего занимает памяти для (2n-1) * k max элементов
48*n*k - 8*k байт
2*n*k - k элементов
10^6 элементов:
    n = 2^7 => k = 3 938, => 2^25 байт => 2^5 = 32 MiB
    n = 2^15 => k = 16 => 2^25 байт => 32 MiB
512 mb max
# кароче, заебало, давай простой вариант
[ ] нужно как-то различать уменьшенные версии чисел и обычные char-овые -
    ставить после строки \0 если переписано число, если нет, то оставлять пробел
сделать свои типы typedef-ом, типа не unsigned char чтобы потом, если что, поменять
блять если туда элемент добавлять, и всё будет смещаться в массиве, то мне придётся менять указатель
    ребёнка на сам элемент, который поменял расположение - проще будет каждый раз искать того самого родителя
    хотя нафига вообще искать? - наверное для разделения нижнего массива-элемента
1.просто считывать в массив ммапом и читаем что там:
       1. если плюс добавляем в дерево-массив

# дерево-массив:
#     [][][]...[] | int - номер первого элемента, который указывает на первую строку+число слева
# элемент дерева-массива:
#     [   2n - 1 элементов в каждом узле, могут быть пустые [][]...[] /
#         указатель на элемент дерева-массива
#         номер элемента
#     /   unsigned char - сколько используется - заполняем слева направо наверное - проще всего /
#     /    ] |
# элемент узла:
#     [   int индекс начала строки + значения | int номер в дереве-массиве правого ребёнка
#         int - номер следующего элемента в дереве-массиве, который указывает на правую строку +
#         unsigned char - номер элемента в этом элементе дерева-массива ]

когда я буду перекидывать дерево, у меня может помняться только положение узлов дерева-массива,
но тогда должны поменяться и все указывающие на него элементы, то есть все дети и 1 родитель,
и по факту, если использовать места удалённых первыми, то перенос может быть легче

мне для переноса строк и значений нужен так-то или список со всеми строками по порядку, в каждом элементе которого
будет указатель на элемент, в котором нужно поменять инт-указатель, или сделать это в самом дереве,
но тогда при переносе придётся также как-то с этим справлятся, то есть при переносе чего-либо придётся менять инт-указатели
в списке связном, то есть связный список - пиздец не юзабельный, нужно в дерево встроить, тогда при переносе всё сохранится,
ну а если я буду перестраивать дерево, тогда мне нужно будет также менять инт-указатели на следующие элементы,
но я не знаю, кто на меня ссылается в текущий момент, если инт-указатели однонаправленные, то есть придётся делать ещё и обратно
но погодите, разве там не будут огромные инт-указатели, ведь мне нужно 2 элемента минимум, чтобы однозначно определить узел,

при переписывании строк можно после неё и до числа писать \n если там переделанное в 8-байт число, и просто пробел, если
там не переделанное, и кста 2 вариант тоже нормальный

при просмотре длины строки можно делать сразу +=2, при просмотре числа тоже

при записи на диск можно просто не менять структуру дерева - это будет очень просто и к тому же не затратно по времени

окончание самой последней команды - проверить правильность выполнения

при поиске я буду получать или самый правый + 1 элемент, то есть он не будет указывать ни на что
или указывать на элемент, вместо которого нужно будет поставить наш элемент, или это будет просто левая ветка

добавить если будет время: начало элементов и тогда добавлять нужно будет в середину с началат т д

блять этот мердж и сплит своевременный это пиздец:
нужно как-то подгадать их
если при адде всё сплитить наверх, то тогда при удалении какого-то там элемента придётся всё вниз мерджить
но можно не делать ни того, ни другого, или только одно, а потом рекурсивно подниматься и делать, если надо
можно при добавлении только сплитить сверху вниз типа
и при удалении мерджить сверху вниз
или всё это делать в конце, но тогда это всё дублируется
